"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const make_dir_1 = __importDefault(require("make-dir"));
const path_1 = __importDefault(require("path"));
const yaml_1 = require("yaml");
const fs_1 = require("fs");
const fast_glob_1 = __importDefault(require("fast-glob"));
const hash_1 = __importDefault(require("./lib/hash"));
const create_codegen_opts_1 = __importDefault(require("./lib/create-codegen-opts"));
const dts_1 = require("./lib/dts");
const memoize_1 = __importDefault(require("./lib/memoize"));
const paths_1 = require("./lib/paths");
const print_1 = require("./lib/print");
const resolver_types_1 = require("./lib/resolver-types");
const util_1 = require("util");
const rimraf_1 = __importDefault(require("rimraf"));
const log_update_1 = __importDefault(require("log-update"));
const graphql_codegen_1 = require("./lib/graphql-codegen");
const rimraf = util_1.promisify(rimraf_1.default);
const { readFile, writeFile } = fs_1.promises;
const processGraphQLCodegen = memoize_1.default(graphql_codegen_1.processGraphQLCodegen, (_, tsxFullPath) => tsxFullPath);
async function gen(commandOpts) {
    log_update_1.default(print_1.PRINT_PREFIX + 'Running graphql-codegen...');
    const { configPath, cwd } = commandOpts;
    const config = yaml_1.parse(await readFile(configPath, 'utf-8'));
    await rimraf(path_1.default.join(cwd, config.generateDir));
    const codegenOpts = await create_codegen_opts_1.default(config, cwd);
    const gqlRelPaths = await fast_glob_1.default(config.documents, { cwd });
    if (gqlRelPaths.length === 0) {
        throw new Error(`No GraphQL documents are found from the path ${JSON.stringify(config.documents)}. Check "documents" in .graphql-let.yml.`);
    }
    const codegenContext = [];
    for (const gqlRelPath of gqlRelPaths) {
        const gqlContent = await readFile(path_1.default.join(cwd, gqlRelPath), 'utf-8');
        const { tsxFullPath, dtsFullPath } = paths_1.createPaths(cwd, config.generateDir, gqlRelPath, hash_1.default(gqlContent));
        await processGraphQLCodegen(codegenOpts, tsxFullPath, gqlRelPath, gqlContent);
        codegenContext.push({ tsxFullPath, dtsFullPath, gqlRelPath });
    }
    if (resolver_types_1.shouldGenResolverTypes(commandOpts, config)) {
        log_update_1.default(print_1.PRINT_PREFIX +
            `Local schema files are detected. Generating resolver types...`);
        const { tsxFullPath, dtsFullPath } = await resolver_types_1.processGenerateResolverTypes(cwd, config, codegenOpts);
        codegenContext.push({
            tsxFullPath,
            dtsFullPath,
            gqlRelPath: config.schema,
        });
    }
    log_update_1.default(print_1.PRINT_PREFIX + 'Generating .d.ts...');
    const dtsContents = dts_1.genDts(codegenContext.map(s => s.tsxFullPath));
    await make_dir_1.default(path_1.default.dirname(codegenContext[0].dtsFullPath));
    for (const [i, dtsContent] of dtsContents.entries()) {
        const { dtsFullPath, gqlRelPath } = codegenContext[i];
        await writeFile(dtsFullPath, dts_1.wrapAsModule(gqlRelPath, dtsContent));
    }
    log_update_1.default(print_1.PRINT_PREFIX +
        `${dtsContents.length} .d.ts were generated in ${paths_1.createDtsRelDir(config.generateDir)}.`);
    log_update_1.default.done();
}
exports.default = gen;
