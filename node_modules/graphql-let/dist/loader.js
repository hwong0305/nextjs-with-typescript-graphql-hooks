"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const log_update_1 = __importDefault(require("log-update"));
const path_1 = require("path");
const yaml_1 = require("yaml");
const dts_1 = require("./lib/dts");
const graphql_codegen_1 = require("./lib/graphql-codegen");
const hash_1 = __importDefault(require("./lib/hash"));
const memoize_1 = __importDefault(require("./lib/memoize"));
const paths_1 = require("./lib/paths");
const consts_1 = require("./lib/consts");
const print_1 = require("./lib/print");
const { readFile } = fs_1.promises;
const processGraphQLCodegenFromConfig = memoize_1.default(graphql_codegen_1.processGraphQLCodegenFromConfig, (_, __, tsxFullPath) => tsxFullPath);
const processGenDts = memoize_1.default(dts_1.processGenDts, dtsFullPath => dtsFullPath);
const graphlqCodegenLoader = function (gqlContent) {
    const callback = this.async();
    // Wrap them because loader.Loader doesn't expect Promise as the returned value
    (async () => {
        try {
            const { resourcePath: gqlFullPath, rootContext: userDir } = this;
            const configPath = path_1.join(userDir, consts_1.DEFAULT_CONFIG_FILENAME);
            const config = yaml_1.parse(await readFile(configPath, 'utf-8'));
            const hash = hash_1.default(gqlContent);
            const { tsxFullPath, dtsFullPath, dtsRelPath, gqlRelPath } = paths_1.createPaths(userDir, config.generateDir, path_1.relative(userDir, gqlFullPath), hash);
            let tsxContent;
            if (fs_1.existsSync(tsxFullPath)) {
                tsxContent = await readFile(tsxFullPath, 'utf-8');
            }
            else {
                log_update_1.default(`${print_1.PRINT_PREFIX}Running graphql-codegen...`);
                tsxContent = await processGraphQLCodegenFromConfig(config, userDir, tsxFullPath, gqlRelPath, String(gqlContent));
            }
            if (!fs_1.existsSync(dtsFullPath)) {
                log_update_1.default(print_1.PRINT_PREFIX + 'Generating .d.ts...');
                await processGenDts(dtsFullPath, tsxFullPath, gqlRelPath);
                log_update_1.default(print_1.PRINT_PREFIX + `${dtsRelPath} was generated.`);
                // Hack to prevent duplicated logs for simultaneous build, in SSR app for an example.
                await new Promise(resolve => setTimeout(resolve, 0));
                log_update_1.default.done();
            }
            // Pretend .tsx for later loaders.
            // babel-loader at least doesn't respond the .graphql extension.
            this.resourcePath = `${gqlFullPath}.tsx`;
            callback(undefined, tsxContent);
        }
        catch (e) {
            log_update_1.default.stderr(print_1.PRINT_PREFIX + e.message);
            log_update_1.default.stderr.done();
            callback(e);
        }
    })();
};
exports.default = graphlqCodegenLoader;
