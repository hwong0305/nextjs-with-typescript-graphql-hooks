"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const make_dir_1 = __importDefault(require("make-dir"));
const path_1 = __importDefault(require("path"));
const typescript_1 = require("typescript");
const { writeFile } = fs_1.promises;
const options = {
    declaration: true,
    emitDeclarationOnly: true,
    skipLibCheck: false,
};
function getModuleNameForPath(p) {
    const baseName = path_1.default.basename(p);
    return baseName.startsWith('*') ? baseName : '*/' + baseName;
}
function wrapAsModule(filePath, content) {
    const moduleName = getModuleNameForPath(filePath);
    return `declare module '${moduleName}' {
  ${content
        .trim()
        // Not sure if it's necessary, is it?
        // .replace(/\nexport declare /g, '\nexport ')
        .replace(/\n/g, '\n  ')}
}`;
}
exports.wrapAsModule = wrapAsModule;
function genDts(tsxFullPaths) {
    const compilerHost = typescript_1.createCompilerHost({});
    const dtsContents = [];
    compilerHost.writeFile = (name, dtsContent) => {
        // To make sure the order of input files and call of "writeFile" consistent
        const pathFragment = path_1.default.join(path_1.default.dirname(name), path_1.default.basename(name, '.d.ts'));
        const tsxFullPath = tsxFullPaths[dtsContents.length];
        if (!tsxFullPath.startsWith(pathFragment)) {
            throw new Error('TypeScript API was not expected as graphql-let developer, it needs to be fixed');
        }
        // TODO: It's more preferable to consuming dtsCnotent here
        // instead of pile them up on memory. Any idea?
        dtsContents.push(dtsContent);
    };
    const program = typescript_1.createProgram(tsxFullPaths, options, compilerHost);
    program.emit();
    if (dtsContents.length !== tsxFullPaths.length) {
        throw new Error('Fails to generate .d.ts.');
    }
    return dtsContents;
}
exports.genDts = genDts;
async function processGenDts(dtsFullPath, tsxFullPath, gqlRelPath) {
    await make_dir_1.default(path_1.default.dirname(dtsFullPath));
    const [dtsContent] = await genDts([tsxFullPath]);
    if (!dtsContent)
        throw new Error(`Generate ${dtsFullPath} fails.`);
    await writeFile(dtsFullPath, wrapAsModule(gqlRelPath, dtsContent));
    return dtsContent;
}
exports.processGenDts = processGenDts;
